<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta property="og:title" content="Gemini + VS Code Agent 架构">
    <meta property="og:description" content="基于 Gemini 1.5 Pro 与 Cline 的多智能体协作开发流">
    <meta property="og:image" content="https://geekheron.github.io/DevLog//logo.png"> 
    <meta property="og:url" 	content="https://geekheron.github.io/DevLog/">
    <meta name="twitter:card" content="summary_large_image">
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Gemini + VS Code Agent 架构 - GeekHeron</title>
    <link rel="icon" type="image/png" href="logo.png">
    <link rel="apple-touch-icon" href="logo.png">
    
    <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
    <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>

    <style>
        /* --- 基础样式 (源自模板) --- */
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            font-family: "Helvetica Neue", Helvetica, Arial, sans-serif;
            background-color: #000;
            color: #ccc;
            min-height: 100vh;
            overflow-x: hidden;
            line-height: 1.8;
            -webkit-font-smoothing: antialiased;
        }
        a { text-decoration: none; color: inherit; transition: 0.3s; }
        
        #galaxy-field { position: fixed; top: 0; left: 0; width: 100%; height: 100%; z-index: -1; }
        .overlay-dark {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0, 0, 0, 0.85); z-index: 0; pointer-events: none;
        }

        /* --- 导航栏 --- */
        header {
            display: flex; justify-content: space-between; align-items: center;
            padding: 30px 50px; border-bottom: 1px solid #333;
            background-color: rgba(0,0,0,0.9); backdrop-filter: blur(10px);
            position: sticky; top: 0; z-index: 100;
        }
        .logo { font-size: 24px; font-weight: 800; letter-spacing: 4px; color: #fff; text-transform: uppercase; }
        .nav-links a { margin-left: 30px; font-size: 13px; font-weight: 600; color: #888; }
        .nav-links a:hover, .nav-links a.active { color: #fff; }

        /* --- 文章容器 --- */
        .container {
            max-width: 800px; margin: 0 auto; padding: 80px 20px 150px;
            position: relative; z-index: 10;
        }

        .article-header {
            margin-bottom: 60px; text-align: center; border-bottom: 1px solid #333; padding-bottom: 40px;
        }
        .article-meta { font-family: monospace; color: #666; font-size: 14px; margin-bottom: 20px; }
        .tag {
            display: inline-block; padding: 2px 8px; border: 1px solid #444; 
            font-size: 12px; border-radius: 2px; margin-left: 10px; color: #888;
        }
        .article-title {
            font-size: 42px; font-weight: 700; letter-spacing: -1px; 
            color: #fff; line-height: 1.3; margin-bottom: 20px;
        }

        /* --- 正文排版 --- */
        .article-content h2 {
            font-size: 28px; color: #fff; margin-top: 60px; margin-bottom: 25px;
            /* 保留模板特色的酸性绿边框 */
            border-left: 4px solid #bfff00; 
            padding-left: 15px;
        }
        .article-content h3 {
            font-size: 20px; color: #e0e0e0; margin-top: 40px; margin-bottom: 15px;
            font-weight: 600;
        }
        .article-content p { margin-bottom: 25px; font-size: 18px; text-align: justify; }
        .article-content ul { margin-bottom: 30px; padding-left: 20px; }
        .article-content li { margin-bottom: 10px; list-style-type: square; color: #bbb; }
        .article-content strong { color: #fff; font-weight: 600; }

        /* --- 特殊组件：技术栈网格 (迁移自原始内容) --- */
        .tech-stack-grid {
            display: grid; grid-template-columns: repeat(auto-fit, minmax(220px, 1fr));
            gap: 20px; margin: 40px 0;
        }
        .tech-card {
            background: rgba(255,255,255,0.05); padding: 25px; border-radius: 8px;
            border: 1px solid rgba(255,255,255,0.1); transition: 0.3s;
        }
        .tech-card:hover { border-color: #bfff00; background: rgba(255,255,255,0.08); }
        .tech-card strong { color: #bfff00; display: block; margin-bottom: 12px; font-size: 16px; letter-spacing: 1px;}
        .tech-card { font-size: 14px; line-height: 1.8; color: #aaa; }

        /* --- 代码块高亮样式 --- */
        .article-content pre {
            background: #111; border: 1px solid #333; padding: 25px;
            border-radius: 8px; overflow-x: auto; margin: 30px 0;
            font-family: "Consolas", "Monaco", monospace; font-size: 14px;
            line-height: 1.6;
        }
        .article-content code { color: #8BE9FD; } 
        .keyword { color: #FF79C6; } 
        .string { color: #F1FA8C; } 
        .comment { color: #6272A4; font-style: italic; } 
        .function { color: #50FA7B; }

        .back-btn {
            display: inline-block; margin-top: 80px;
            font-size: 14px; color: #666; border: 1px solid #333;
            padding: 10px 20px; transition: 0.3s;
        }
        .back-btn:hover { border-color: #fff; color: #fff; }

        /* --- 移动端适配 --- */
        @media (max-width: 768px) {
            header { flex-direction: column; padding: 15px 20px; gap: 15px; }
            .nav-links { display: flex; width: 100%; justify-content: space-between; flex-wrap: wrap; gap: 10px; }
            .nav-links a { margin-left: 0; font-size: 14px; }
            .container { padding: 40px 20px 100px; }
            .article-title { font-size: 28px; line-height: 1.3; }
            .tech-stack-grid { grid-template-columns: 1fr; }
        }
    </style>
</head>
<body>

    <canvas id="galaxy-field"></canvas>
    <div class="overlay-dark"></div>

    <header>
        <a href="index.html" class="logo">GeekHeron</a>
        <nav class="nav-links">
            <a href="index.html">首页</a>
            <a href="article.html" class="active">深度分析</a>
            <a href="works.html">作品展示</a>
            <a href="about.html">关于博主</a>
        </nav>
    </header>

    <main class="container">
        <div class="article-header">
            <div class="article-meta">
                <span>2026.01.09</span>
                <span class="tag">AI AGENT</span>
                <span class="tag">DEV TOOLS</span>
            </div>
            <h1 class="article-title">Gemini + VS Code 智能体架构：<br>当 AI 成为你的全栈同事</h1>
            <p style="color: #888; max-width: 600px; margin: 0 auto; font-size: 16px;">
                基于 Gemini 1.5 Pro 与 Cline 的多智能体协作开发流。深度拆解从模糊需求分析到全自动落地代码的流水线设计。
            </p>
        </div>

        <article class="article-content">
            
            <p>本文档详述了如何搭建一个<strong>多智能体协作（Multi-Agent Collaboration）</strong>开发环境。该架构采用 Gemini 担任产品经理（Brain），VS Code Agent 担任全栈工程师（Hands），实现从模糊需求到落地代码的全自动流水线。</p>

            
            <div class="tech-stack-grid">
                <div class="tech-card">
                    <strong>Role A: Product Manager</strong>
                    Gemini 1.5 Pro<br>2M Token Context<br>需求分析 & 架构设计<br>生成 Blueprint
                </div>
                <div class="tech-card">
                    <strong>Role B: Lead Developer</strong>
                    VS Code + Cline (Plugin)<br>File System Access<br>Terminal Execution<br>Error Fixing
                </div>
                <div class="tech-card">
                    <strong>Protocol</strong>
                    System Prompts (.clinerules)<br>Markdown Docs<br>JSON Specs<br>Human-in-the-loop
                </div>
            </div>

            <h2>1. 核心设计：脑手分离</h2>
            <p>在传统的 AI 辅助编程中，用户往往直接要求 AI "写一个贪吃蛇"。这种单步指令容易导致逻辑混乱。本架构引入了<strong>流水线机制</strong>：</p>
            <ul>
                <li><strong>上游 (Gemini PM)：</strong> 负责规划。输入模糊需求，输出结构化的技术文档 (PRD/Blueprint) 和目录结构。不直接写代码。</li>
                <li><strong>下游 (VS Code Agent)：</strong> 负责执行。读取上游生成的 Markdown 计划，通过工具调用 (Tool Use) 操作本地文件系统和终端。</li>
            </ul>

            <h2>2. 最佳实践方案 (Best Practice)</h2>
            <p>我们推荐使用 <strong>VS Code + Cline 插件 + Gemini 1.5 Pro</strong> 的零代码组合。Gemini 1.5 Pro 的超大上下文窗口使其能够“记住”整个项目库，完美胜任架构师角色。</p>

            <h3>2.1 注入“PM 灵魂” (System Prompt)</h3>
            <p>为了防止 AI 一上来就盲目编码，我们需要通过 System Prompt 强制执行 "Think First" 策略。以下配置需写入 Cline 的 <code>Custom Instructions</code> 或项目根目录的 <code>.clinerules</code> 文件：</p>

            <pre><code><span class="comment"># Role: Technical Product Manager & Lead Architect</span>
You are an expert combination of a Product Manager and a Software Architect. 

<span class="keyword"># Workflow Protocol (STRICTLY FOLLOW)</span>

<span class="string">**Phase 1: Discovery & Architecture (NO CODE YET)**</span>
When the user gives a requirement:
1. <span class="function">Analyze</span>: Identify the core goal and key features.
2. <span class="function">Tech Stack</span>: Choose the most modern stack (e.g., Vite/Vue3).
3. <span class="function">Draft Blueprint</span>: Create a file named <span class="code">PROJECT_BLUEPRINT.md</span> containing:
    - User Stories
    - File Structure (Tree view)
    - Step-by-Step Implementation Plan
4. <span class="function">STOP & ASK</span>: "Does this architecture look good to proceed?"

<span class="string">**Phase 2: Execution (The "Coder" Mode)**</span>
ONLY after the user approves:
1. Initialize the project (<span class="code">npm create...</span>).
2. Follow the plan in <span class="code">PROJECT_BLUEPRINT.md</span>.
3. Verify each step with a test run.</code></pre>

            <h2>3. 标准作业程序 (SOP)</h2>
            <p>在实际开发中，遵循以下交互流程可以获得最佳效果：</p>

            <h3>Step 1: 需求下达</h3>
            <p><strong>用户：</strong>“我想做一个简单的网页版番茄钟，要有倒计时和统计功能，界面极简。”<br>
            <strong>Gemini (PM)：</strong>分析需求，生成 <code>PROJECT_BLUEPRINT.md</code>，规划技术栈为 Vue3 + TailwindCSS。</p>

            <h3>Step 2: 架构确认</h3>
            <p><strong>用户：</strong>查看 Markdown 计划，确认无误后回复：“确认，开始开发。”<br>
            <em>注：此时可进行人工干预，例如要求更换数据库或调整 UI 风格。</em></p>

            <h3>Step 3: 自动化执行</h3>
            <p><strong>Gemini (Coder)：</strong>切换角色，自动执行终端命令：<br>
            <code>npm create vite@latest</code> -> <code>npm install</code> -> 创建组件文件。它会根据 Phase 1 的蓝图逐个落实文件。</p>

            <h2>4. 潜在挑战与方案</h2>
            <p>尽管该架构非常强大，但在复杂项目中仍需注意以下几点：</p>
            <ul>
                <li><strong>上下文丢失：</strong> 尽管 1.5 Pro 窗口很大，但对于超大型项目，建议定期让 Agent 生成 <code>PROGRESS.md</code> 总结当前进度，并开启新会话 (New Task)。</li>
                <li><strong>幻觉代码：</strong> 在 Prompt 中强制要求 Agent 在引入第三方库前，必须先运行 <code>npm install</code> 并验证库是否存在。</li>
                <li><strong>死循环：</strong> 设置最大重试次数。如果 Agent 陷入报错-修复的死循环，应及时暂停并人工介入。</li>
            </ul>

        </article>

        <a href="article.html" class="back-btn">← 返回文章列表</a>
    </main>

    <script>
        /* 粒子背景动画 (保持统一) */
        const canvas = document.getElementById('galaxy-field');
        const ctx = canvas.getContext('2d');
        let width, height;
        const particles = [];
        const isMobile = window.innerWidth < 768;
        const numParticles = isMobile ? 400 : 1500;
        
        function resize() {
            width = window.innerWidth; height = window.innerHeight;
            canvas.width = width; canvas.height = height;
        }
        
        class Particle {
            constructor() {
                this.x = Math.random() * width; this.y = Math.random() * height;
                this.vx = (Math.random() - 0.5) * 0.2; this.vy = (Math.random() - 0.5) * 0.2;
                this.size = Math.random() * 1.5; this.alpha = Math.random() * 0.5 + 0.1;
            }
            update() {
                this.x += this.vx; this.y += this.vy;
                if(this.x < 0) this.x = width; if(this.x > width) this.x = 0;
                if(this.y < 0) this.y = height; if(this.y > height) this.y = 0;
            }
            draw() {
                ctx.fillStyle = `rgba(255, 255, 255, ${this.alpha})`;
                ctx.beginPath(); ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2); ctx.fill();
            }
        }

        function init() { resize(); for(let i=0; i<numParticles; i++) particles.push(new Particle()); }
        function animate() {
            ctx.clearRect(0, 0, width, height);
            particles.forEach(p => { p.update(); p.draw(); });
            requestAnimationFrame(animate);
        }
        window.addEventListener('resize', () => { resize(); particles.length = 0; init(); });
        init(); animate();
    </script>
</body>
</html>