<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta property="og:title" content="伏羲引擎技术架构 v2.0">
    <meta property="og:description" content="从真太阳时到 AI 编排：传统命理的数字化重构实录">
    <meta property="og:image" content="logo.png"> 
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>伏羲引擎技术架构深度拆解 - GeekHeron</title>
    <style>
        /* --- 基础样式变量 --- */
        :root {
            --bg-color: #0a0a0a;
            --text-main: #e0e0e0;
            --text-dim: #888;
            --accent-gold: #d4af37;
            --code-bg: #1a1a1a;
            --border-color: rgba(255, 255, 255, 0.1);
        }

        * { margin: 0; padding: 0; box-sizing: border-box; }

        body {
            font-family: "SF Pro Display", "Helvetica Neue", Arial, sans-serif;
            background-color: var(--bg-color);
            color: var(--text-main);
            line-height: 1.8;
            font-size: 16px;
        }

        /* --- 动态背景 --- */
        #galaxy-canvas {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%; z-index: -1;
            opacity: 0.6;
        }

        /* --- 布局容器 --- */
        .container {
            max-width: 900px;
            margin: 0 auto;
            padding: 60px 24px;
            position: relative;
            z-index: 10;
        }

        /* --- 头部样式 --- */
        header {
            margin-bottom: 80px;
            border-bottom: 1px solid var(--border-color);
            padding-bottom: 40px;
        }

        .brand {
            font-size: 14px;
            color: var(--accent-gold);
            letter-spacing: 2px;
            text-transform: uppercase;
            font-weight: 700;
            margin-bottom: 16px;
            display: block;
        }

        h1 {
            font-size: 42px;
            font-weight: 700;
            letter-spacing: -0.5px;
            line-height: 1.2;
            margin-bottom: 16px;
            background: linear-gradient(to right, #fff, #888);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
        }

        .meta-info {
            color: var(--text-dim);
            font-family: monospace;
            font-size: 13px;
        }

        /* --- 文章内容样式 --- */
        article h2 {
            font-size: 26px;
            color: #fff;
            margin-top: 60px;
            margin-bottom: 24px;
            padding-left: 16px;
            border-left: 3px solid var(--accent-gold);
        }

        article h3 {
            font-size: 18px;
            color: var(--text-main);
            margin-top: 40px;
            margin-bottom: 16px;
            font-weight: 600;
        }

        article p {
            margin-bottom: 24px;
            text-align: justify;
            color: #ccc;
        }

        article strong {
            color: #fff;
            font-weight: 600;
        }

        /* --- 代码块优化 --- */
        pre {
            background: var(--code-bg);
            border: 1px solid var(--border-color);
            border-radius: 8px;
            padding: 20px;
            overflow-x: auto;
            margin: 30px 0;
            font-family: "JetBrains Mono", Consolas, monospace;
            font-size: 13px;
        }

        code {
            color: var(--accent-gold);
        }

        .comment { color: #6a9955; }
        .keyword { color: #c586c0; }
        .string { color: #ce9178; }
        .function { color: #dcdcaa; }

        /* --- 引用块 --- */
        blockquote {
            background: rgba(212, 175, 55, 0.05);
            border-left: 4px solid var(--accent-gold);
            padding: 24px;
            margin: 40px 0;
            font-style: italic;
            color: #ddd;
        }

        /* --- 列表 --- */
        ul {
            margin-left: 20px;
            margin-bottom: 30px;
            color: #ccc;
        }
        li { margin-bottom: 12px; }

        /* --- 底部导航 --- */
        .footer-nav {
            margin-top: 100px;
            padding-top: 40px;
            border-top: 1px solid var(--border-color);
            display: flex;
            justify-content: space-between;
        }
        .back-link {
            color: var(--text-dim);
            text-decoration: none;
            transition: color 0.2s;
        }
        .back-link:hover { color: #fff; }

        /* --- 响应式 --- */
        @media (max-width: 768px) {
            h1 { font-size: 32px; }
            .container { padding: 40px 20px; }
        }
    </style>
</head>
<body>

    <canvas id="galaxy-canvas"></canvas>

    <div class="container">
        <header>
            <span class="brand">GeekHeron / Engineering</span>
            <h1>伏羲引擎 (Fuxi Engine) v2.0 <br>技术架构深度拆解</h1>
            <p class="meta-info">
                // STACK: PYTHON FLASK · DEEPSEEK V3 · SQLALCHEMY · ASTRO-ALGORITHMS<br>
                // UPDATED: 2026.01.20
            </p>
        </header>

        <article>
            <blockquote>
                <strong>摘要：</strong> 
                传统的在线排盘系统往往只是对农历库的简单封装，而“AI 算命”则常陷入大模型幻觉与套话的泥潭。
                伏羲引擎 v2.0 重构了底层逻辑：引入天文级精度的“真太阳时”校正算法，构建了基于 context-injection 的 AI 编排层，并解决了一系列 Python Web 开发中的跨域工程挑战。
                本文将基于核心代码库（<code>bazi_engine.py</code>, <code>ai_service.py</code>, <code>config.py</code>）进行源码级复盘。
            </blockquote>

            <h2>1. 核心算力：从“时钟时间”到“真太阳时”</h2>
            <p>
                在 <code>app/services/bazi_engine.py</code> 的重构中，最大的技术突破是引入了 <strong>真太阳时 (True Solar Time)</strong> 系统。
                传统算法直接使用用户输入的钟表时间（平太阳时），这在命理学上是极其粗糙的。北京时间 12:00 在新疆（东经87度）实际上太阳还在爬坡，而在哈尔滨（东经126度）太阳已经西斜。
            </p>
            
            <h3>1.1 经度校正与均时差</h3>
            <p>我们引入了 <code>time_utils.py</code>，通过用户输入的地理经度（<code>longitude</code>），结合当日的 <strong>均时差 (Equation of Time)</strong> 进行二次校正。代码逻辑如下：</p>

            <pre><code><span class="keyword">def</span> <span class="function">calculate_bazi_data</span>(year, month, day, hour, minute, ... longitude):
    <span class="comment"># ... (省略基础校验)</span>
    
    <span class="keyword">if</span> longitude <span class="keyword">is not None</span>:
        <span class="comment"># 调用天文工具库计算真太阳时</span>
        <span class="comment"># 解决了“同一个钟表时间，不同地点八字时柱完全不同”的边缘 Case</span>
        tst = get_true_solar_time(base_year, base_month, base_day, hour, minute, float(longitude))
        year, month, day, hour, minute = tst.year, tst.month, tst.day, tst.hour, tst.minute
        is_true_solar = <span class="keyword">True</span>
    
    <span class="comment"># 继续使用 Lunar 库进行干支转换...</span></code></pre>

            <h3>1.2 数字化量化系统</h3>
            <p>为了让 AI 理解“强弱”概念，我们在 <code>BaziLogic</code> 类中实现了一套加权打分算法。系统遍历四柱干支，计算日主（Me Wuxing）在月令的得令情况以及其他三柱的生助情况，最终输出一个 <code>0-100</code> 的量化分数。这些硬数据（Hard Data）是后续 AI 推理的基石。</p>

            <h2>2. AI 编排层：Prompt 工程与防幻觉机制</h2>
            <p>在 <code>app/services/ai_service.py</code> 中，我们没有选择简单的“Chat”模式，而是构建了一个基于 RAG 思想的上下文注入系统。</p>

            <h3>2.1 解决 LLM 的“时间感知缺失”</h3>
            <p>通用大模型（如 DeepSeek V3）本身没有“今年是哪一年”的实时感知，直接询问流年运势往往会得到基于其训练截止日期的错误回答（例如它可能认为今年还是 2023 年）。</p>
            <p>我们在生成 Prompt 时，强制注入了当前的时间锚点：</p>
            <pre><code><span class="keyword">def</span> <span class="function">generate_prompt</span>(data, ...):
    <span class="comment"># 强制注入服务器当前计算出的年份，防止 AI 幻觉</span>
    current_luck = data.get(<span class="string">"current_luck"</span>, {})
    numeric_year = current_luck.get(<span class="string">"meta"</span>, {}).get(<span class="string">"year_str"</span>, <span class="string">"2026年"</span>)
    
    base_info = f<span class="string">"""
    【当前时间基准】
    公历年份: {numeric_year}
    流年干支: {liunian_ganzhi}年 (AI请务必基于此年份进行运势推演，不要使用默认训练数据时间)
    """</span></code></pre>

            <h3>2.2 合规与安全层 (Safety Layer)</h3>
            <p>作为面向公众的 SaaS 服务，合规性至关重要。我们在代码中定义了全局常量 <code>COMPLIANCE_DISCLAIMER</code>，并将其硬编码到每一个 System Prompt 的尾部。这强制要求 AI：</p>
            <ul>
                <li><strong>语言风格：</strong> 必须使用理性、客观的心理学/统计学术语。</li>
                <li><strong>负面清单：</strong> 严禁出现“注定”、“血光之灾”、“前世今生”等宿命论词汇。</li>
                <li><strong>输出规范：</strong> 所有预测必须以“倾向”、“潜质”等非确定性口吻表述。</li>
            </ul>

            <h2>3. 工程实战：CORS 跨域与 Cookie 的爱恨情仇</h2>
            <p>在前后端分离（前端 VSCode Live Server :5500，后端 Flask :5000）的开发环境中，<strong>跨域资源共享 (CORS)</strong> 和 <strong>Session 丢失</strong> 是最耗时的工程坑。</p>
            
            <p>在 <code>app/__init__.py</code> 和 <code>app/config.py</code> 中，我们留下了一组“战损版”的配置，完美解决了 Nginx 反代环境下的 Cookie 传递问题：</p>

            <pre><code><span class="comment"># 1. 必须明确指定 Origins，不能用通配符 '*'</span>
<span class="comment"># 否则浏览器会拒绝携带 Credentials (Cookie)</span>
allowed_origins = [
    <span class="string">"http://localhost:5500"</span>, 
    <span class="string">"https://www.fuxiengine.xyz"</span>
]

<span class="comment"># 2. CORS 初始化</span>
CORS(app, 
     supports_credentials=<span class="keyword">True</span>, <span class="comment"># 关键：允许跨域 Cookie</span>
     resources={r"/*": {<span class="string">"origins"</span>: allowed_origins}})

<span class="comment"># 3. Cookie 策略 (Config.py)</span>
<span class="comment"># Lax 是现代浏览器在安全性与可用性之间的最佳平衡</span>
SESSION_COOKIE_SAMESITE = <span class="string">'Lax'</span> 
<span class="comment"># 在非 HTTPS 的开发/宝塔环境中，强制关闭 Secure 也是为了防止 Session 丢失</span>
SESSION_COOKIE_SECURE = <span class="keyword">False</span></code></pre>

            <h2>4. 商业化闭环：卡密与数据模型</h2>
            <p>项目的变现逻辑并非简单的接入 Stripe，而是设计了一套解耦的 <strong>卡密系统 (CardKey System)</strong>。</p>
            <ul>
                <li><strong>模型设计：</strong> <code>CardKey</code> 表（见 <code>app/models.py</code>）包含 <code>code</code> (唯一索引)、<code>key_type</code> (VIP月卡/点数包) 和状态位。</li>
                <li><strong>核销流程：</strong> 用户在前端输入卡密 -> 调用 <code>/redeem</code> 接口 -> 后端原子化更新用户 <code>vip_expiry</code> 或 <code>credits</code> -> 标记卡密为 <code>is_used</code>。</li>
                <li><strong>优势：</strong> 这种设计将“支付”与“履约”完全解耦。无论是通过 Crypto 支付、微信转账还是 LemonSqueezy，只要生成对应的卡密字符串即可完成发货，极大地降低了支付网关的对接复杂度。</li>
            </ul>

            <h2>5. 总结</h2>
            <p>
                伏羲引擎 v2.0 不仅仅是一个算命玩具，它是一次将传统算法（lunar_python）、现代 AI 工程（DeepSeek）与 Python Web 最佳实践（Flask Blueprint/SQLAlchemy）深度融合的尝试。
                它证明了，即使是再传统的领域，通过严谨的代码重构与架构设计，也能焕发出具有现代感的数字化生命力。
            </p>

        </article>

        <div class="footer-nav">
            <a href="index.html" class="back-link">← 返回首页</a>
            <span class="meta-info">GeekHeron © 2026</span>
        </div>
    </div>

    <script>
        // 简单的背景星空效果
        const canvas = document.getElementById('galaxy-canvas');
        const ctx = canvas.getContext('2d');
        let width, height;
        const stars = [];

        function resize() {
            width = window.innerWidth;
            height = window.innerHeight;
            canvas.width = width;
            canvas.height = height;
        }

        function initStars() {
            stars.length = 0;
            for(let i=0; i<300; i++) {
                stars.push({
                    x: Math.random() * width,
                    y: Math.random() * height,
                    r: Math.random() * 1.5,
                    a: Math.random() * 0.5 + 0.1,
                    s: Math.random() * 0.02
                });
            }
        }

        function animate() {
            ctx.clearRect(0, 0, width, height);
            ctx.fillStyle = "#fff";
            stars.forEach(star => {
                star.a += star.s;
                if(star.a > 0.8 || star.a < 0.1) star.s = -star.s;
                ctx.globalAlpha = star.a;
                ctx.beginPath();
                ctx.arc(star.x, star.y, star.r, 0, Math.PI*2);
                ctx.fill();
            });
            requestAnimationFrame(animate);
        }

        window.addEventListener('resize', () => { resize(); initStars(); });
        resize(); initStars(); animate();
    </script>
</body>
</html>